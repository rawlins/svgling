[
  {
    "objectID": "index.html#installation-and-logistics",
    "href": "index.html#installation-and-logistics",
    "title": "The svgling package: Linguistic tree diagrams in python + SVG",
    "section": "1.1 Installation and logistics",
    "text": "1.1 Installation and logistics\nTo install the release version from PyPI, use the pip command line tool: pip install svgling. On managed jupyter-based systems such as google colab, you can install by entering !pip install svgling into a notebook cell. The current unreleased version of svgling can also be installed from source via the github repository: https://github.com/rawlins/svgling. On a managed system, the simplest way to do this is to run !pip install git+https://github.com/rawlins/svgling. Please report bugs on that repository via the issue tracker on github if you encounter any!\nOnce it is installed, to activate the package, you can run:\n\nimport svgling\n\nIf you would like to reset tree drawing options to the default on import, you can call:\n\nsvgling.core.reset_defaults()"
  },
  {
    "objectID": "index.html#basic-usage",
    "href": "index.html#basic-usage",
    "title": "The svgling package: Linguistic tree diagrams in python + SVG",
    "section": "1.2 Basic usage",
    "text": "1.2 Basic usage\nFor convenient use in Jupyter notebooks, the main function to try is svgling.draw_tree:\n\nsvgling.draw_tree((\"S\", \"NP\", \"VP\"))\n\n\n\n\nAs a shortcut, the outer bracketing here can be omitted:\n\nsvgling.draw_tree(\"S\", \"NP\", (\"VP\", \"V\"))\n\n\n\n\nMulti-line nodes are generally possible. Simply provide the node as a string that includes \\n where a linebreak is desired. The next example, a more complex tree with multi-line leaf nodes, also shows how to get the leaf nodes to be lined up with each other. (This tree is from Carnie 2013, Syntax: a generative introduction (3rd ed.), p. 93.)\n\nsvgling.draw_tree(\"TP\", (\"NP\", \"D\\nThe\", (\"AdjP\", (\"AdvP\", \"Adv\\nvery\"), \"Adj\\nsmall\"), \"N\\nboy\"), (\"VP\", \"V\\nkissed\", (\"NP\", \"D\\nthe\", \"N\\nplatypus\")), leaf_nodes_align=True)"
  },
  {
    "objectID": "index.html#more-advanced-tricks",
    "href": "index.html#more-advanced-tricks",
    "title": "The svgling package: Linguistic tree diagrams in python + SVG",
    "section": "1.3 More advanced tricks",
    "text": "1.3 More advanced tricks\nThe svgling package supports a wide range of complex formatting as well as “tree annotations” like movement arrows. The following example provides a quick illustration; see the full package manual for a complete list of possible formatting options.\nThis example illustrates a typical tree for Quantifier Raising in the Heim & Kratzer 1998 (“Semantics in Generative Grammar”) style, illustrating movement arrows and tree annotation from the svgling.figure module. See the diagram gallery for an even more elaborate variant of this example.\n\nt2 = (\"TP\", (\"DP\", (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n           (\"TP\", \"1\", (\"TP\", (\"DP\", (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\"))),\n                     (\"TP\", \"3\", (\"TP\", (\"DP\", svgling.core.subscript_node(\"t\", \"1\")),\n                                  (\"VP\", (\"V\", \"likes\"), (\"DP\", svgling.core.subscript_node(\"t\", \"3\"))))))))\n\nsvgling.core.reset_defaults() # reset any defaults in case this is run out of order\nf = svgling.core.cssfont(\"verdana, arial, sans-serif\", style=\"oblique\")\n\n(svgling.draw_tree(t2, leaf_padding=3) # use a slightly wider padding than the default\n    # mark binders and traces in red\n    .set_node_style((1,0), text_color=\"red\")\n    .set_node_style((1,1,1,0), text_color=\"red\")\n    .set_node_style((1,1,1,1,0,0), text_color=\"red\")\n    .set_node_style((1,1,1,1,1,1,0), text_color=\"red\")\n    # set leaf nodes in bold sans-serif\n    .set_leaf_style(font_style=f)\n    # draw movement arrows and underline moved constituents\n    .movement_arrow((1,1,1,1,0), (0,))\n    .underline_constituent((0,))\n    .movement_arrow((1,1,1,1,1,1), (1,1,0))\n    .underline_constituent((1,1,0)))"
  },
  {
    "objectID": "index.html#integration-with-nltk",
    "href": "index.html#integration-with-nltk",
    "title": "The svgling package: Linguistic tree diagrams in python + SVG",
    "section": "2.1 Integration with NLTK",
    "text": "2.1 Integration with NLTK\nThe svgling package is well-integrated with the nltk (https://www.nltk.org/) package. This package uses svgling for rendering of nltk.tree.Tree objects in Jupyter by default (using it to implement a _repr_svg_(), and svgling supports nltk.tree.Tree objects in any context where a tree can be provided.\n\nimport nltk\nt3 = nltk.Tree.fromstring(\"(S (NP (D the) (N elephant)) (VP (V saw) (NP (D the) (N rhinoceros))))\")\nt3\n\n\n\n\nOptions available as named parameters can also be set on a global basis by modifying the options object at svgling.core.default_options, and this provides a quick way to change settings for nltk trees. For example, to change font size for all rendered trees:\nsvgling.core.default_options.font_size = 20\nGlobal defaults can be reset via svgling.core.reset_defaults().\nFor more complex styling of nltk trees, including tree annotations, you can directly supply a nltk.tree.Tree object to svgling.draw_tree:\n\nsvgling.draw_tree(t3, leaf_nodes_align=True).box_constituent((0,))\n\n\n\n\nOther parts of svgling support Trees as well, in particular, the svgling.figure utility classes."
  },
  {
    "objectID": "index.html#exporting-to-raster-formats",
    "href": "index.html#exporting-to-raster-formats",
    "title": "The svgling package: Linguistic tree diagrams in python + SVG",
    "section": "2.2 Exporting to raster formats",
    "text": "2.2 Exporting to raster formats\nThe svgling packages supports exporting to raster formats via cairosvg. Convenience wrappers are provided via svgling.util, and the full cairosvg api can be used as well. See the manual for more details, but here is an example of one of t3 as a png:\n\nimport cairosvg # this cell needs cairosvg in order to run\nimport svgling.utils, svgling.semantics\nfrom IPython.display import Image\nt = svgling.semantics.DoubleBrackets(t3)\nImage(svgling.utils.svg2png(t, scale=1.5))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About svgling",
    "section": "",
    "text": "The svgling package is, at its core, a single-pass python system for rendering constituent trees to SVG diagrams, intended primarily for use with Jupyter notebooks. It was first released in 2018 as a replacement for what at the time was the only available tree drawing approach for Jupyter, nltk’s _repr_png_ implementation, and has developed from there.\n\nAuthor: Kyle Rawlins, kgr@jhu.edu\nDependencies: svgwrite, python 3, (optional) cairosvg\nRepository and issue tracker: https://github.com/rawlins/svgling/\nInstallation: download from github and use setuptools, or pip install svgling to install the current release version from PyPI.\nLicense: MIT License"
  },
  {
    "objectID": "about.html#about-the-package",
    "href": "about.html#about-the-package",
    "title": "About svgling",
    "section": "",
    "text": "The svgling package is, at its core, a single-pass python system for rendering constituent trees to SVG diagrams, intended primarily for use with Jupyter notebooks. It was first released in 2018 as a replacement for what at the time was the only available tree drawing approach for Jupyter, nltk’s _repr_png_ implementation, and has developed from there.\n\nAuthor: Kyle Rawlins, kgr@jhu.edu\nDependencies: svgwrite, python 3, (optional) cairosvg\nRepository and issue tracker: https://github.com/rawlins/svgling/\nInstallation: download from github and use setuptools, or pip install svgling to install the current release version from PyPI.\nLicense: MIT License"
  },
  {
    "objectID": "about.html#about-the-author",
    "href": "about.html#about-the-author",
    "title": "About svgling",
    "section": "About the author",
    "text": "About the author\nThe svgling package is developed by Kyle Rawlins. I’m a faculty member in the Cognitive Science department at JHU; my research areas are in theoretical and computational linguistics, focusing on semantics and pragmatics. This package originally came about as a side project of my interest in scientific computing for linguistics in Jupyter and Python, and has since taken on a life of its own."
  },
  {
    "objectID": "about.html#about-the-website",
    "href": "about.html#about-the-website",
    "title": "About svgling",
    "section": "About the website",
    "text": "About the website\nThis website is rendered from runnable Jupyter notebooks using quarto. The source notebooks and page generation code can be found at: https://github.com/rawlins/svgling/tree/master/docs."
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "svgling diagram gallery",
    "section": "",
    "text": "Code\nimport svgling\nfrom svgling import draw_tree\nfrom svgling.figure import Caption, SideBySide, RowByRow\nfrom svgling.core import subscript_node\nThis gallery provides several examples of relatively complex SVG tree diagrams rendering using the svgling package. To begin with, here is an example from Carnie (2012) that illustrates multiline nodes paired with aligned leaf nodes.\nCode\nCaption(draw_tree(\"TP\", (\"NP\", \"D\\nThe\", (\"AdjP\", (\"AdvP\", \"Adv\\nvery\"), \"Adj\\nsmall\"), \"N\\nboy\"), (\"VP\", \"V\\nkissed\", (\"NP\", \"D\\nthe\", \"N\\nplatypus\")),\n                  leaf_nodes_align=True),\n        \"Tree from Carnie 2012, p. 93\")\nThe following example illustrates Quantifier Raising (QR) in the style of Heim and Kratzer (1998), involving movement arrows, subfigures, and subtree highlighting.\nCode\nqrtree0 = (\"TP\", (\"DP\", (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n                                   (\"VP\", (\"V\", \"likes\"), (\"DP\", (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\")))))\nout0 = Caption(draw_tree(qrtree0), \"LF input (= Surface Structure)\")\n\nqrtree1 = (\"TP\", (subscript_node(\"DP\", \"1\"), (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n                                   (\"VP\", (\"V\", \"likes\"), (subscript_node(\"DP\", \"3\"), (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\")))))\nout1 = draw_tree(qrtree1)\nout1.box_constituent((0,))\nout1.box_constituent((1,1))\nout1 = Caption(out1, \"Step 1: free indexing (1 of 2 indexings)\")\n\nqrtree2 = (\"TP\", (\"DP\", (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\"))),\n                      (\"TP\", \"3\", (\"TP\", (subscript_node(\"DP\", \"1\"), (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n                                   (\"VP\", (\"V\", \"likes\"), (\"DP\", subscript_node(\"t\", \"3\"))))))\nout2 = draw_tree(qrtree2)\nout2.movement_arrow((1,1,1,1), (0,))\nout2.box_constituent((0,))\nout2.box_constituent((1,1,0))\nout2 = Caption(out2, \"Step 2: QR an indexed DP (choosing the object)\")\n\nqrtree3 = (\"TP\", (\"DP\", (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n           (\"TP\", \"1\", (\"TP\", (\"DP\", (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\"))),\n                     (\"TP\", \"3\", (\"TP\", (\"DP\", subscript_node(\"t\", \"1\")), (\"VP\", (\"V\", \"likes\"), (\"DP\", subscript_node(\"t\", \"3\"))))))))\nout3 = draw_tree(qrtree3)\nout3.movement_arrow((1,1,1,1,0), (0,))\nout3.box_constituent((0,))\nout3.movement_arrow((1,1,1,1,1,1), (1,1,0))\nout3.box_constituent((1,1,0))\nout3 = Caption(out3, \"Step 3: QR an indexed DP (choosing the subject).\")\n\nCaption(RowByRow(SideBySide(out0, out1), SideBySide(out2,out3)), \"Trees illustrating a QR (Quantifier Raising) derivation in the Heim & Kratzer 1998 style\")\nThe following example, based on a tree from McCloskey (2000), demonstrates multi-headed movement arrows.\nCode\nmccloskey = (\"FP\", (\"F\", (\"V\", \"put\")),\n             (\"AgrOP\", (subscript_node(\"DP\", \"Obj\"), \"milk\"),\n              (\"\", (\"AgrO\", subscript_node(\"t\", \"V\")),\n               (\"VP\", subscript_node(\"t\", \"Subj\"), (\"\", subscript_node(\"t\", \"V\"),\n                                  (\"VP\", (\"PP\", \"in it\"), (\"\", (\"V\", subscript_node(\"t\", \"V\")), subscript_node(\"t\", \"Obj\"))))))))\n\n# TODO: AgrOP should be set with a subscript O, currently not supported.\nout = draw_tree(mccloskey)\nout.set_edge_style((1,0,0), svgling.core.TriangleEdge())\nout.set_edge_style((1,1,1,1,1,0,0), svgling.core.TriangleEdge())\nout.movement_arrow((1,1,1,1,1,1,0,0), (1,1,0,0))\nout.movement_arrow((1,1,0,0), (0,0,0))\nout.movement_arrow((1,1,1,1,1,1,1), (1,0))\nCaption(out, \"Tree after ex. 58 of McCloskey (2000)\")\nThe following example, which is based on a PCFG example from the classic Hale (2001) account of garden path sentences, illustrates how to use a custom tree parsing function together with a non-default node renderer. An nltk probabilistic parser returns a subclass of tree that uses label() normally, but also has a probability value indicating the “inside probability” of the subtree given its constituents. There’s a provided function svgling.core.ptree_split that renders such trees in an ugly but functional way; this example improves on that a bit by using subscripts.\nThe example constructs a nltk.grammar.PCFG object based on an example in Hale (2001), parses a sentence using that PCFG, and draws the resulting tree incorporating inside probabilities into the node labels.\nCode\nimport nltk, nltk.parse\nfrom nltk.grammar import PCFG\n\n# note: this is a binarized version of an example grammar due to Hale in the cited paper.\nhale1 = PCFG.fromstring(\"\"\"\n    S0 -&gt; S '.'     [1.0]\n    S -&gt; NP VP     [1.0]\n    NP -&gt; DT NN    [0.88]\n    NP -&gt; NP VP    [0.12]\n    PP -&gt; IN NP    [1.0]\n    VP -&gt; VBD PP   [0.17]\n    VP -&gt; VBN PP   [0.75]\n    VP -&gt; VBD      [0.08]\n    DT -&gt; 'the'    [1.0]\n    NN -&gt; 'horse'  [0.5]\n    NN -&gt; 'barn'   [0.5]\n    VBD -&gt; 'fell'  [0.5]\n    VBD -&gt; 'raced' [0.5]\n    VBN -&gt; 'raced' [1.0]\n    IN -&gt; 'past'   [1.0]\n    \"\"\")\n# parse \"The horse raced past the barn fell.\" using one of nltk's chart parsers:\nhale1_parser = nltk.parse.pchart.InsideChartParser(hale1)\nparses = list(hale1_parser.parse(\"the horse raced past the barn fell .\".split()))\n\ndef ptree_split2(t):\n    try:\n        return (svgling.core.subscript_node(f\"{t.label()}\", f\"p={t.prob()}\", scale=0.85), list(t))\n    except AttributeError:\n        # indicate that this function doesn't handle `t`. (Leaf nodes of this tree\n        # class are `str` -- this leaves them to the default node parser.)\n        return None\n\nsvgling.draw_tree(parses[0], tree_split=ptree_split2)"
  },
  {
    "objectID": "gallery.html#hybrid-svghtml-diagram-examples",
    "href": "gallery.html#hybrid-svghtml-diagram-examples",
    "title": "svgling diagram gallery",
    "section": "Hybrid svg/html diagram examples",
    "text": "Hybrid svg/html diagram examples\nThe following tree is a typical example of how compositional semantics might be integrated into a tree structure in formal semantics. This tree is not pure SVG (which doesn’t support latex code), but is rendered using svgling.html.\n\n\nCode\nimport svgling.html\nsvgling.html.compat(svgling.html.Compat.USE_MARKDOWN) # needed for quarto\nfrom svgling.html import multiline_text as ml\n\ndef math(s):\n    # note: we are in markdown mode, so using delimiters with backslashes becomes harder...\n    return f\"${s}$\"\n\nsvgling.html.draw_tree(\n    ml(math(r\"\\text{Saw}(\\iota x_e{:\\:}\\text{Elephant}(x),\\iota x_e{:\\:}\\text{Rhino}(x))\"), math(r\"\\text{Type: }t\")),\n    (ml(math(r\"\\iota x_e{:\\:}\\text{Elephant}(x)\"), math(r\"\\text{Type: }e\")),\n         ml(math(r\"\\lambda f_{\\langle e,t \\rangle }{:\\:}\\iota x_e{:\\:}f(x)\"),\n            math(r\"\\text{Type: }\\langle \\langle e,t\\rangle ,e\\rangle\")),\n         ml(math(r\"\\lambda x_e{:\\:}\\text{Elephant}(x)\"), math(r\"\\text{Type: }\\langle e,t\\rangle\"))),\n    (ml(math(r\"\\lambda x_e{:\\:}\\text{Saw}(x,\\iota x_e{:\\:}\\text{Rhino}(x))\"), math(r\"\\text{Type: }\\langle e,t\\rangle\")),\n         ml(math(r\"\\lambda y_e{:\\:}\\lambda x_e{:\\:}\\text{Saw}(x,y)\"),\n            math(r\"\\text{Type: }\\langle e,\\langle e,t\\rangle\\rangle\")),\n         (ml(math(r\"\\iota x_e{:\\:}\\text{Rhino}(x)\"), math(r\"\\text{Type: }e\")),\n              ml(math(r\"\\lambda f_{\\langle e,t \\rangle }{:\\:}\\iota x_e{:\\:}f(x)\"),\n                 math(r\"\\text{Type: }\\langle \\langle e,t\\rangle ,e\\rangle\")),\n              ml(math(r\"\\lambda x_e{:\\:}\\text{Rhino}(x)\"), math(r\"\\text{Type: }\\langle e,t\\rangle\")))))\n\n\n\n\n\n\n\\(\\text{Saw}(\\iota x_e{:\\:}\\text{Elephant}(x),\\iota x_e{:\\:}\\text{Rhino}(x))\\)\n\n\n\\(\\text{Type: }t\\)\n\n\n\n\n\n\n\\(\\text{Saw}(\\iota x_e{:\\:}\\text{Elephant}(x),\\iota x_e{:\\:}\\text{Rhino}(x))\\)\n\n\n\\(\\text{Type: }t\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\iota x_e{:\\:}\\text{Elephant}(x)\\)\n\n\n\\(\\text{Type: }e\\)\n\n\n\n\n\n\n\\(\\iota x_e{:\\:}\\text{Elephant}(x)\\)\n\n\n\\(\\text{Type: }e\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda f_{\\langle e,t \\rangle }{:\\:}\\iota x_e{:\\:}f(x)\\)\n\n\n\\(\\text{Type: }\\langle \\langle e,t\\rangle ,e\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda x_e{:\\:}\\text{Elephant}(x)\\)\n\n\n\\(\\text{Type: }\\langle e,t\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda x_e{:\\:}\\text{Saw}(x,\\iota x_e{:\\:}\\text{Rhino}(x))\\)\n\n\n\\(\\text{Type: }\\langle e,t\\rangle\\)\n\n\n\n\n\n\n\\(\\lambda x_e{:\\:}\\text{Saw}(x,\\iota x_e{:\\:}\\text{Rhino}(x))\\)\n\n\n\\(\\text{Type: }\\langle e,t\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda y_e{:\\:}\\lambda x_e{:\\:}\\text{Saw}(x,y)\\)\n\n\n\\(\\text{Type: }\\langle e,\\langle e,t\\rangle\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\iota x_e{:\\:}\\text{Rhino}(x)\\)\n\n\n\\(\\text{Type: }e\\)\n\n\n\n\n\n\n\\(\\iota x_e{:\\:}\\text{Rhino}(x)\\)\n\n\n\\(\\text{Type: }e\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda f_{\\langle e,t \\rangle }{:\\:}\\iota x_e{:\\:}f(x)\\)\n\n\n\\(\\text{Type: }\\langle \\langle e,t\\rangle ,e\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\lambda x_e{:\\:}\\text{Rhino}(x)\\)\n\n\n\\(\\text{Type: }\\langle e,t\\rangle\\)"
  },
  {
    "objectID": "gallery.html#more-diagrams",
    "href": "gallery.html#more-diagrams",
    "title": "svgling diagram gallery",
    "section": "More diagrams?",
    "text": "More diagrams?\nI’d be excited to get both new diagram requests, and PRs for new diagrams: https://github.com/rawlins/svgling."
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Changelog for svgling",
    "section": "",
    "text": "This version is intended to be the last release that is marked as a beta / pre-1.0 version.\nNew features:\n\nSupport for arbitrary SVG node contents, via the node_builder decorator\nSupport for handling of custom tree node classes, via the TreeOptions option tree_split, as well as a pre-provided handler for nltk’s ProbabilisticTree class\nBuilt-in node builder (svgling.core.subscript_node) for nodes that have a subscript\nA figure class HTMLSideBySide that allows mixing hybrid HTML diagrams with SVG diagrams\n\nDocumentation:\n\nMajor documentation improvements, convert docs to quarto\n\nFixes, improvements, changes:\n\nSupport a repeated call notation for most TreeLayout public functions\nImprovements to the draw_tree and tree2svg APIs\nFix for constituent underlines at the exact lower edge of a figure\nCompatibility mode for rendering (some) svgling.html diagrams in quarto\nRefactor of the node construction API that goes along with the node_builder change\nBuild/install improvements\n\n\n\n\nAs of 0.3.1, svgling is the default tree-drawing package for nltk Trees in Jupyter; this update provides better compatibility for that. It also improves some styling options, and direct support for format conversion.\nNew features:\n\nLimited per-node styling in trees: supports changing font style, size, and color/fill\nconvenience wrappers to make conversion to PNG/PDF via the cairosvg package easier (cairosvg is now an optional package dependency)\nSupport nltk.Tree objects directly in svgling.figure classes\n\nFixes, improvements, changes:\n\nSimplify import code for nltk, remove monkeypatching\nThe option global_font_style is renamed to just font_style\nRefactor TreeOptions to make it easier to pass around options bundles\nDefault change: relative_units=False. This provides better compatibility with inkscape, among other things. This option is now deprecated.\nDocumentation improvements\n\n\n\n\nNew feature:\n\nCompatibility mode aimed at Inkscape: allow using px instead of relative em units. This allows current versions of Inkscape to load the output SVGs. This mode is not on by default.\n\nFixes, improvements, changes:\n\nUpdate documentation to reflect some issues in MathJax math mode delimeter choice for hybrid mode.\n\n\n\n\nNew features:\n\nBasic support for drawing trees using a mix of HTML/CSS (for positioning) and SVG (for line drawing). This is much more limited than the core drawing algorithms, but allows for arbitrary node labels + MathJax.\n\nFixes, improvements, changes:\n\nImprove documentation\n\n\n\n\nNew features:\n\nSupport for multi-line nodes.\nEdge styles, muti-segment descents for level skipping.\nWrote a manual.\nTree annotations: movement arrows, constituent highlighting / underlining.\nComplex figures: grids of trees, captioning.\n\nFixes, improvements, changes:\n\nMassively improve responsivity of svgling diagrams.\nTreeLayout objects manage font size directly.\ndistance_to_daughter is now a distance between levels, i.e. excluding node height.\n\n\n\n\n\nFix for non-leaf nodes that are larger than the leaf nodes they dominate.\nMore flexible arguments to draw_tree (will accept the top node + children via variable arguments, rather than a list/tuple as the first argument.)\nDocumentation improvements.\n\n\n\n\n\nSupport for basic tree drawing with lists and nltk.tree.Tree objects."
  },
  {
    "objectID": "CHANGELOG.html#documentation-and-node-rendering---2024-08-20",
    "href": "CHANGELOG.html#documentation-and-node-rendering---2024-08-20",
    "title": "Changelog for svgling",
    "section": "",
    "text": "This version is intended to be the last release that is marked as a beta / pre-1.0 version.\nNew features:\n\nSupport for arbitrary SVG node contents, via the node_builder decorator\nSupport for handling of custom tree node classes, via the TreeOptions option tree_split, as well as a pre-provided handler for nltk’s ProbabilisticTree class\nBuilt-in node builder (svgling.core.subscript_node) for nodes that have a subscript\nA figure class HTMLSideBySide that allows mixing hybrid HTML diagrams with SVG diagrams\n\nDocumentation:\n\nMajor documentation improvements, convert docs to quarto\n\nFixes, improvements, changes:\n\nSupport a repeated call notation for most TreeLayout public functions\nImprovements to the draw_tree and tree2svg APIs\nFix for constituent underlines at the exact lower edge of a figure\nCompatibility mode for rendering (some) svgling.html diagrams in quarto\nRefactor of the node construction API that goes along with the node_builder change\nBuild/install improvements"
  },
  {
    "objectID": "CHANGELOG.html#node-styling-and-compatibility---2023-09-25",
    "href": "CHANGELOG.html#node-styling-and-compatibility---2023-09-25",
    "title": "Changelog for svgling",
    "section": "",
    "text": "As of 0.3.1, svgling is the default tree-drawing package for nltk Trees in Jupyter; this update provides better compatibility for that. It also improves some styling options, and direct support for format conversion.\nNew features:\n\nLimited per-node styling in trees: supports changing font style, size, and color/fill\nconvenience wrappers to make conversion to PNG/PDF via the cairosvg package easier (cairosvg is now an optional package dependency)\nSupport nltk.Tree objects directly in svgling.figure classes\n\nFixes, improvements, changes:\n\nSimplify import code for nltk, remove monkeypatching\nThe option global_font_style is renamed to just font_style\nRefactor TreeOptions to make it easier to pass around options bundles\nDefault change: relative_units=False. This provides better compatibility with inkscape, among other things. This option is now deprecated.\nDocumentation improvements"
  },
  {
    "objectID": "CHANGELOG.html#inkscape-compatibility---2021-10-11",
    "href": "CHANGELOG.html#inkscape-compatibility---2021-10-11",
    "title": "Changelog for svgling",
    "section": "",
    "text": "New feature:\n\nCompatibility mode aimed at Inkscape: allow using px instead of relative em units. This allows current versions of Inkscape to load the output SVGs. This mode is not on by default.\n\nFixes, improvements, changes:\n\nUpdate documentation to reflect some issues in MathJax math mode delimeter choice for hybrid mode."
  },
  {
    "objectID": "CHANGELOG.html#hybrid-htmlsvg-tree-drawing---2018-12-10",
    "href": "CHANGELOG.html#hybrid-htmlsvg-tree-drawing---2018-12-10",
    "title": "Changelog for svgling",
    "section": "",
    "text": "New features:\n\nBasic support for drawing trees using a mix of HTML/CSS (for positioning) and SVG (for line drawing). This is much more limited than the core drawing algorithms, but allows for arbitrary node labels + MathJax.\n\nFixes, improvements, changes:\n\nImprove documentation"
  },
  {
    "objectID": "CHANGELOG.html#core-features-complete---2018-11-26",
    "href": "CHANGELOG.html#core-features-complete---2018-11-26",
    "title": "Changelog for svgling",
    "section": "",
    "text": "New features:\n\nSupport for multi-line nodes.\nEdge styles, muti-segment descents for level skipping.\nWrote a manual.\nTree annotations: movement arrows, constituent highlighting / underlining.\nComplex figures: grids of trees, captioning.\n\nFixes, improvements, changes:\n\nMassively improve responsivity of svgling diagrams.\nTreeLayout objects manage font size directly.\ndistance_to_daughter is now a distance between levels, i.e. excluding node height."
  },
  {
    "objectID": "CHANGELOG.html#bugfix-release---2018-11-8",
    "href": "CHANGELOG.html#bugfix-release---2018-11-8",
    "title": "Changelog for svgling",
    "section": "",
    "text": "Fix for non-leaf nodes that are larger than the leaf nodes they dominate.\nMore flexible arguments to draw_tree (will accept the top node + children via variable arguments, rather than a list/tuple as the first argument.)\nDocumentation improvements."
  },
  {
    "objectID": "CHANGELOG.html#first-real-release---2018-11-7",
    "href": "CHANGELOG.html#first-real-release---2018-11-7",
    "title": "Changelog for svgling",
    "section": "",
    "text": "Support for basic tree drawing with lists and nltk.tree.Tree objects."
  },
  {
    "objectID": "manual.html",
    "href": "manual.html",
    "title": "svgling Manual",
    "section": "",
    "text": "Code\nimport svgling, svgling.html, svgling.figure\nfrom svgling.figure import SideBySide, RowByRow, Caption"
  },
  {
    "objectID": "manual.html#background-svg-formatting",
    "href": "manual.html#background-svg-formatting",
    "title": "svgling Manual",
    "section": "2.1 Background: SVG formatting",
    "text": "2.1 Background: SVG formatting\nMany options through this document interact with SVG formatting, via arguments pass to the svgwrite API. I won’t specify the details of this here, see the svgwrite docs for details. Generally, svgwrite formatting parameters are validated and passed transparently through to svg itself with the python _ character turned into -, so for details of how svgwrite parameters are interpreted, also see the SVG specification (and whatever viewer-specific documentation there is - not all SVG renderers are alike). I have generally not passed through all parameters, but rather chosen a few that I think are the most useful. Two key parameters that show up repeatedly for lines are stroke (which gets filled in with a color or none) and stroke_width (which gets filled in with a measurement, usually in user units for svgling trees).\nUnits: SVG uses CSS-style units, which can be a little confusing. Here’s a quick reference primer on the ones that will come up in this manual.\n\nuser units: the default internal unit of an SVG diagram. For svgling trees, at their default sizing, 1 is equivalent to 1px. However, trees may be resized depending on the display context.\npx: stands for “pixel”, but does not necessarily correspond literally to a pixel in CSS; the interpretation is more abstract. The increment 1px corresponds to an optical reference unit that is the smallest object likely to be visible on a screen. Some but not all displays can render objects that are less than 1px.\nem: the height of one line of text, at the current font size, from baseline to baseline.\n%: percentage of the immediately containing SVG box.\npt: a unit inherited from print typography, but again in CSS this is interpreted kind of abstractly and won’t really correspond to any reliable physical distance (what you might expect from the history). Not recommended for screen-oriented rendering. For css and svg, 1pt = 0.75px (so 12pt = 16px, for the most useful special case)."
  },
  {
    "objectID": "manual.html#sec-nodes-constituents",
    "href": "manual.html#sec-nodes-constituents",
    "title": "svgling Manual",
    "section": "2.2 Nodes and constituents",
    "text": "2.2 Nodes and constituents\nNodes: The core draw_tree interface accepts trees as lists of nodes and (recursively) trees, as described above. A node can be either:\n\nA string, that will (more or less) be rendered as-is\nThe output of a node-builder function\n\nA string node may span multiple lines, which are separated by \\n. For example: \"N\\ncat\" gives a two-line node with N as the first line and cat as the second. Within a node, multiple lines are anchored at the middle (leading to centering). A label consisting of the empty string \"\" is considered empty, and will not render at all – the lines will be joined in the middle of the row height. If you want a blank label, any sequence of whitespace will work, e.g. \" \".\n\nsvgling.draw_tree(\"DP\", \"D\\nthe\", (\"AP\", \"A\\ngray\"), (\"NP\", \"N\\ncat\"))\n\n\n\n\nNode builder functions may be used to write custom node rendering (see Section 4.8 for more on this). At the moment, two are provided by default: multiline_node implements the default multiline string handling, and subscript_node implements a node with subscripting. node may be used as a shortcut to the default (and changing it will change the default behavior).\nSo for example, the following is equivalent to the simpler invocation in the previous cell, but explicitly parses the nodes:\n\nfrom svgling.core import node\nsvgling.draw_tree(node(\"DP\"), node(\"D\\nthe\"), (node(\"AP\"), node(\"A\\ngray\")), (node(\"NP\"), node(\"N\\ncat\")))\n\n\n\n\nThe following example illustrates using the subscript node buiilder. Currently, the subscript builder does not support newlines.\n\nsvgling.draw_tree(\"CP\",\n                  (\"DP\", svgling.core.subscript_node(\"who\", \"i\")),\n                  (\"TP\", (\"DP\", svgling.core.subscript_node(\"t\", \"i\")),\n                         (\"VP\", \"danced\")))\n\n\n\n\nSelecting nodes and constituents: For various purposes discussed throughout this manual, you can select particular parts of a tree (usually nodes or constituents) for formatting. To do this, you use what is sometimes called a tree path. These are sequences of indices that traverse the tree from the root node by choosing a daughter in left-to-right order. Indices begin at 0.\nSo for example, the path (0,1,1) gives the second daughter of the second daughter of the first daughter of the root node. The empty path () gives the subtree headed at the root. As this example illustrates, a path needn’t be complete, and for annotation purposes will typically be interpreted as selecting an entire constituent, though for some purposes it may select a node. As a reminder, a length 1 path written as a tuple will require a comma so that python can disambiguate it from just a regular number in parenthesis, e.g. (0,). A path that selects a daughter node whose index is greater than the number of daughters at that point in the tree is invalid. Using negative indices is possible, and these will be interpreted like negative indices in python: e.g. -1 selects the rightmost node, etc.\nThe following diagram illustrates some example valid tree paths as python tuples.\n\nsvgling.draw_tree((\"()\", (\"(0,)\", (\"(0,0)\", \"(0,0,0)\"), (\"(0,1)\", \"(0,1,0)\", \"(0,1,1)\")),\n                         (\"(1,)\", \"(1,0)\", (\"(1,1)\", \"(1,1,0)\"), (\"(1,2)\", \"(1,2,0)\", (\"(1,2,1)\", \"(1,2,1,0)\")))),\n                 font_style=svgling.core.MONO, average_glyph_width=1.5)\n\n\n\n\nRelative to the above tree, the paths (2,) and (1,0,0) would (for example) be invalid. The paths (-1,-1,-1) and (-1,2,-2) (for example) would select the subtree identified by (1,2,1) and (1,2,0) respectively.\nAn invalid path will result in an IndexError exception.\nCustom tree class handling: In order to handle custom tree classes, you can define a function to convert arbitrary node classes into strings and provide it via the tree_split options parameter. This function should, given an argument t, return a tuple consisting of a node label in the first element, and a possibly empty sequence of subtrees in the second element. It may return None to indicate that the node class isn’t handled by the function (in which case, built in conversion will be used.) As a simple example, here is a split function for objects using the nltk.Tree api – a version of this function is built in and automatically used when needed, but the API for custom functions is exactly the same.\n\ndef split_nltk(t):\n    try:\n        # a Tree object stores the node label on `label()`, and child nodes as a list.\n        return (t.label(), list(t))\n    except AttributeError:\n        return None\n\nOne application for this is nltk.tree.probabilistic.ProbabilisticTree objects, and a simple split function is provided as svgling.core.probtree_split that renders both the label and the probability for each node that has one. See discussion below in the section NLTK integration."
  },
  {
    "objectID": "manual.html#layout-overview",
    "href": "manual.html#layout-overview",
    "title": "svgling Manual",
    "section": "4.1 Layout overview",
    "text": "4.1 Layout overview\nVertical layout: A node at depth \\(n\\) (where the root node of the tree is depth \\(0\\)) is positioned vertically in a line with all other nodes of depth \\(n\\). Exception (see below for examples): if leaf_nodes_align is set to true, any leaf nodes are aligned with the lowest level of the tree, rather than depth they would otherwise be at. Within a row, vertical space is allowed for the tallest node at that depth; positioning of shorter nodes at that depth is configurable. Vertical spacing is calculated/generated in ems.\nHorizontal layout: The horizontal position of daughter nodes relative to a parent is determined by a (configurable) algorithm, usually based on some measure of the size of the daughter nodes. By default, this algorithm estimates the max text width taken up by the parent node label or the width of daughter nodes (and their daughters, etc). See below for examples of other options. No node will be positioned vertically below a node that does not dominate it. There is also a configurable padding parameter. Horizontal spacing is calculated initially in estimated ems, but (canvas width aside) is converted to percentages for svg layout. Because svgling does not do multi-pass rendering, it uses heuristics for glyph width rather than accurately calculating glyph width. (To do this, you’d basically need to render to a device, and see what happens.)\nCanvas layout: The canvas width is estimated from node text width + padding. The canvas height is determined by the tree depth, level heights, with an extra 1em at the bottom of the canvas for descenders from leaf node glyphs."
  },
  {
    "objectID": "manual.html#debug-and-compatibility-options",
    "href": "manual.html#debug-and-compatibility-options",
    "title": "svgling Manual",
    "section": "4.2 Debug and compatibility options",
    "text": "4.2 Debug and compatibility options\ndebug: When this option is set to True, the rendered will show a 1em grid, as well as a red box for every subtree. This can be useful if something isn’t doing what you expect. Several of the documentation examples below use this to illustrate various spacing options.\n\nsvgling.draw_tree(t1, debug=True)\n\n\n\n\nrelative_units: When this option is set to False, do not use relative units in the generated svg (e.g. no ems). This will instead use px values generated from the local font options. This is not guaranteed to work in general, but it should at least work with standard cases where there is no complicated font manipulation. This option is designed for compatibility with Inkscape.\n\nsvgling.draw_tree(t1, relative_units=False)"
  },
  {
    "objectID": "manual.html#overall-layout-options",
    "href": "manual.html#overall-layout-options",
    "title": "svgling Manual",
    "section": "4.3 Overall layout options",
    "text": "4.3 Overall layout options\nThe following are TreeOptions parameters that affect layout.\nhoriz_spacing: This parameter determines how daughter nodes are spaced horizontally relative to the parent. Possible values are svgling.core.HorizSpacing.TEXT (default; space proportionally based on estimated text width), svgling.core.HorizSpacing.EVEN (space evenly based on number of immediate daughters), and svgling.core.HorizSpacing.NODES (space proportionally to the number of leaf nodes in the subtrees).\nUsually TEXT looks best, but the other two may be preferable for abstract trees where label widths are all similar. Without manual adjustment, the two other options will deal poorly with long labels.\n\nexamples = list()\ndemo_trees = [t0, t1]\nfor opt in svgling.core.HorizSpacing:\n    row = list()\n    for t in range(len(demo_trees)):\n        # debug mode on so that the exact rendering differences are very obvious\n        row.append(Caption(svgling.draw_tree(demo_trees[t], horiz_spacing=opt, debug=True), \"Example t%d with horiz_spacing=%s\" % (t, str(opt))))\n    examples.append(SideBySide(*row))\n\nRowByRow(*examples)\n\n\n\n\naverage_glyph_width: A heuristic factor used to calculate text widths; basically, a divisor in ems. Defaults to 2.0. Does not generally need to be adjusted for default settings (which try to just use Times), but may be worth adjusting for custom fonts.\nleaf_padding: An amount to pad each leaf by, in glyphs. Will be divided by average_glyph_width. Default is 2. Negative values are possible, but will usually result in text being cut off. Leaf padding is applied as a constant to the overall canvas size regardless of the value of horiz_spacing (i.e. the canvas size is always determined by the sum of node widths plus leaf padding at every widest subtree), so will impact spacing to some degree for any setting of this option, but is only applied directly to each leaf for HorizSpacing.TEXT.\n\nexamples = list()\nfor i in (0, 2, 5, -2):\n    examples.append(Caption(svgling.draw_tree(t1, leaf_padding=i), \"Example t1 with leaf_padding=%g\" % i))\nRowByRow(*examples)\n\n\n\n\nvert_align: How row alignment when there are multi-line labels should be calculated. If all labels in a row have the same height, this has no impact, but if there are differences, it controls the position of the shorter node labels vertically. Default is centered. For empty labels, this affects the position of the line join. The values TOP, CENTER, and BOTTOM are self-explanatory. svgling.VertAlign.EVEN causes all nodes to be treated as the same height (relative to their row) regardless of text contents, even empty nodes.\n\nt4 = (\"X\", (\"multiline\\nlabel\", \"Y\"), (\"\", \"Z\\nA\"), (\"A\", \"B\"), \"C\")\n\nexamples = list()\nfor opt in svgling.core.VertAlign:\n    examples.append(Caption(svgling.draw_tree(t4, vert_align=opt), \"Example t4 with vert_align=%s\" % str(opt)))\n\nRowByRow(*examples)\n\n\n\n\ndistance_to_daughter: The distance between rows in ems – that is, distance from the bottom of one row to the top of another. Values less than about 0.5 are not recommended and will usually result in rendering oddities. Default is 2.\nNote that a margin for glyph descenders is included in the distance between levels (not in the node height), so a value of 0.25ems (by default) will give perfectly straight lines, rather than 0.0. This value can be accessed as svgling.core.NodePos.descender_margin.\n\nexamples = list()\nfor i in (0.5, 2, 4, svgling.core.NodePos.descender_margin):\n    examples.append(Caption(svgling.draw_tree(t1, distance_to_daughter=i), \"Example t1 with distance_to_daughter=%g\" % i))\nRowByRow(*examples)"
  },
  {
    "objectID": "manual.html#line-and-node-positioning-options",
    "href": "manual.html#line-and-node-positioning-options",
    "title": "svgling Manual",
    "section": "4.4 Line and node positioning options",
    "text": "4.4 Line and node positioning options\nleaf_nodes_align: if true, will align all leaf nodes with the lowest depth leaf nodes in the tree.\n\nSideBySide(svgling.draw_tree(t1, leaf_nodes_align=True), svgling.draw_tree(\"DP\", \"D\\nthe\", (\"AP\", \"A\\ngray\"), (\"NP\", \"N\\ncat\"), leaf_nodes_align=True))\n\n\n\n\ndescend_direct: When an edge skips levels (currently only possible for leaf nodes, when leaf_nodes_align=True), should the line go directly from the parent to the daughter? If False, the line will go to the position that the daughter would have been at as if there is an empty node there, and descend vertically. This can be useful for very deep trees where a True value results in overlapping, and also in some cases may just look better. However, it doesn’t allow distinguishing empty nodes visually in the tree. As with empty nodes, the positioning of the line join is affected by vert_align. Defaults to True.\nThe following example shows a tree that renders quite badly without this option set to True, because of the asymmetry between leaf node widths.\n\nt4 = (\"A\", \"B\", (\"C\", (\"D\", \"middle leaf\"), \"H\"), (\"E\", \"long leaf\", \"G\"))\nexamples = list()\nfor opt in (True, False):\n    examples.append(Caption(svgling.draw_tree(t4, leaf_nodes_align=True, descend_direct=opt), \"Example t4 with descend_direct=%s\" % str(opt)))\nSideBySide(*examples)\n\n\n\n\nleaf_edges: set to False to suppress edges leading to leaf nodes; more specifically, this draws the edge as an EmptyEdge still with the default distance value (0.0); see below for more on this edge style."
  },
  {
    "objectID": "manual.html#edge-styles",
    "href": "manual.html#edge-styles",
    "title": "svgling Manual",
    "section": "4.5 Edge styles",
    "text": "4.5 Edge styles\nCustom styles can be applied to specific edges. The main application for this is drawing so-called “triangles of laziness”, but it does also allow you to change the color of particular edges and other related things. There is currently no way to change the edge styles for a tree as a whole (I’ll implement such a thing if there’s demand for it). Be aware that non-direct descents are implemented as an edge style, so if you apply a style to a leaf node with leaf_nodes_align=True, then it can override the indirect descent style; use the IndirectDescent class to avoid this.\nThere are several classes that encapsulate edge styles: * svgling.core.EdgeStyle is the default edge style. It allows two svg parameters: stroke and stroke_width. * svgling.core.IndirectDescent implements indirect descents for nodes that skip levels. It inherits the svg parameters of EdgeStyle. This can be set globally via the descend_direct. * svgling.core.TriangleEdge draws a triangle with points at the center of the parent, and the left and right bounds of the daughter text. (Note that, as usual, text width is calculated heuristically.) This class also inherits the svg parameters of EdgeStyle. * svgling.core.EmptyEdge draws nothing at all. This has a configurable distance parameter, defaulting to 0.0. A value of 0.0 puts the top of the lower node at the baseline of the upper node. Pass auto_distance=True to instead use the distance that a regular edge would use. To set a value for all such edges, you can set svgling.core.EmptyEdge.default_distance (None here means use auto_distance=True). A main use of this is to easily do (what will be rendered as) multi-line nodes when working with nltk.\nTo set an edge style on a specific edge, call set_edge_style on the layout object with a path and one of the above objects. This function (and most that annotate or modify the style of a tree) modifies a tree object in place, but it also returns self in order to allow repeated styling calls, as in the following example:\n\nt5 = (\"S\", (\"NP\", \"The subject of this sentence\"), (\"VP\", \"is collapsed\"))\n\n# repeated styling calls without an intermediate assignment:\nout = (svgling.draw_tree(t5)\n       .set_edge_style((0,0), svgling.core.TriangleEdge())\n       .set_edge_style((1,0), svgling.core.TriangleEdge()))\n\n# now for some gratuitous formatting. Let's use a simpler assignment style for this one:\nout.set_edge_style((0,), svgling.core.EdgeStyle(stroke_width=4, stroke=\"red\"))\nout.set_edge_style((1,), svgling.core.EdgeStyle(stroke_width=4))\nout\n\n\n\n\nGiven a tree object with arbitrary styling, you can obtain a default-styled instance of the tree by calling reset(). This function returns a copy, and does not modify the original.\n\nout.reset()"
  },
  {
    "objectID": "manual.html#text-options",
    "href": "manual.html#text-options",
    "title": "svgling Manual",
    "section": "4.6 Text options",
    "text": "4.6 Text options\nfont_style: a css-formatted string that will be used to style text in the tree. Since this is css, you can put all sorts of stuff in it, but I recommend at least including font-family, font-weight, and font-style, because without these font rendering may be inconsistent depending on where the svg is embedded (for example showing as serif in some settings, sans-serif in others). If you are sharing your svg with others, I recommend sticking to web-safe fonts, with fallbacks. The default values is: \"font-family: times, serif; font-weight:normal; font-style: normal;\". You cannot set font size this way.\nA convenience function, svgling.core.cssfont takes a family and an optional named weight and style parameter and produces these strings. In addition, svgling.core.SERIF (the default), svgling.core.SANS, and svgling.core.MONO provide some useful presets.\nfont_size: a numeric value, to be interpreted in user units, for the font size. At the default sizing, 1 user unit corresponds to 1px; SVG diagrams may be resized arbitrarily so changing the font size does not in general guarantee a bigger diagram, but it usually does. The default is 16 (which corresponds to 12pt at the default scaling).\ntext_color: change the color of text in a tree. This option takes css color values. See css documentation for more on what the valid options are.\n\nt1 = (\"S\", (\"NP\", (\"D\", \"the\"), (\"N\", \"rhinoceros\")), (\"VP\", (\"V\", \"saw\"), (\"NP\", (\"D\", \"the\"), (\"A\", \"gray\"), (\"N\", \"elephant\"))))\nstyles = ((\"font-family: georgia, times, serif; font-weight:normal; font-style: normal;\", 26, \"black\"),\n          (\"font-family: sans-serif; font-weight:normal; font-style: normal;\", 16, \"red\"),\n          (svgling.core.cssfont(\"impact, times, serif\", style=\"italic\"), 12, \"#FF69B4\"))\n\nexamples = list()\nfor i in range(len(styles)):\n    examples.append(Caption(svgling.draw_tree(t1, font_style=styles[i][0], font_size=styles[i][1], text_color=styles[i][2]),\n                            \"Example t1 with style %d\" % i))\nRowByRow(*examples)"
  },
  {
    "objectID": "manual.html#per-node-styling",
    "href": "manual.html#per-node-styling",
    "title": "svgling Manual",
    "section": "4.7 Per-node styling",
    "text": "4.7 Per-node styling\nA limited amount of per-node styling is possible, via the functions set_subtree_style, set_node_style, and set_leaf_style on an existing tree. The first two of these take a tree path and some options, and the third just takes options. These currently allow changing only the font size, style, and color, and turning on debug mode for part of the tree.\nCaveats: * The tree layout is still primarily determined by the global font size. In particular, the distance_to_daughter option is always interpreted relative to that font size. So if you are changing many nodes, it can make sense to adjust the global tree font size as well. * Adding per-node styling will reset any existing tree annotations, so you will need to apply annotation calls after node styling calls.\n\nout = svgling.draw_tree(t1)\nout.set_leaf_style(font_style = svgling.core.cssfont(\"impact, times, serif\", style=\"italic\"))\nout.set_node_style((1,1), font_size=30, text_color=\"red\")\nout.set_subtree_style((0,), font_size=10, debug=True)\nout"
  },
  {
    "objectID": "manual.html#sec-custom-nodes",
    "href": "manual.html#sec-custom-nodes",
    "title": "svgling Manual",
    "section": "4.8 Advanced: custom node rendering",
    "text": "4.8 Advanced: custom node rendering\nSection 2.2 provided examples of how to use the built-in node builder functions. The svgling package also allows you to define custom node-builder functions, and by doing so, use arbitrary SVG in a tree node, via the svgwrite package. A node-builder function should be decorated with @svgling.core.node_builder and return a svgling.core.NodePos object that has the correct dimensions set (currently, these cannot be inferred from SVG). NodePos is a wrapper class for an arbitrary SVG object using the svgwrite package. The details of constructing SVG diagrams progamattically go somewhat beyond the scope of this manual, and I won’t explain the SVG format or the svgwrite api in detail here. But generally, you will want to construct svgwrite.container.SVG objects that contain svgwrite.text.Text objects, possibly with svgwrite.text.TSpan objects within those.\nSpecific notes on constructing NodePos and the contained svg objects:\n\nMinimally, the returned NodePos should have width and height set (otherwise, they default to 0). These can be set as named parameters to the constructor, or via the set_dimensions function, which also takes them as named parameters.\nIt is also recommended to set text to something readable, so that the object can be inspected without svg rendering.\nx and y can be used to shift position relative to the tree; x=50 centers (and is probably what you want in most cases).\nUser coordinates can be assumed to match px, and for text rendering, unless you explicitly set font size, you should use the provided options value to get font sizing via em (provides a string with units) and em_to_px (provides a number in user coordinates).\nThe options parameter will be filled in when building a tree, but you should allow for direct calls for debugging.\nThe position of 0,0 is relative to a container constructed on top of NodePos. You can assume that it will have the width specified by NodePos, with height specified by NodePos with some extra y space; the below example demonstrates this.\nTips: use debug mode. Draw reference points when testing (e.g. svgwrite.shapes.Circle((0,0), r=3, fill=options.text_color)).\n\nThe following cell provides a small example of implementing a node builder. As you can see, the svg standard is the limit in what you can draw here, but dealing with positioning is overall not entirely trivial. A good node builder will also be responsive to the options provided from a tree context, illustrated in the text settings below.\n\nimport svgwrite\n\n@svgling.core.node_builder\ndef flip_node(text, sideways=False, options=None):\n    if options is None:\n        options = svgling.core.TreeOptions()\n\n    # get the text width in `em`s based on the input string\n    width = options.label_width(text)\n    svg_parent = svgwrite.container.SVG(x=0, y=0, width=\"100%\")\n    # general recipe for setting up an appropriate Text object. We are inheriting\n    # style from the tree other than these.\n    svgtext = svgwrite.text.Text(text, insert=(\"50%\", # x pos at 50%\n                                               svgling.core.em(1, options)), # y pos (baseline) at 1em\n                                               text_anchor=\"middle\", # align text in the middle\n                                               fill=options.text_color, # use options to set fill/stroke\n                                               stroke=options.text_stroke)\n    # the hard part is figuring out the center point to rotate around, which is in user\n    # coordinates relative to the node container. The center position of a line of text\n    # is not simply 0.5em, because the baseline-to-baseline distance includes space for\n    # an ascender, and not space for a descender. In addition, the normal node margin\n    # applies only to the bottom of a node, not the top. Therefore, adjust the center\n    # downwards by approximately the height of a descender, to ensure half a descender\n    # margin on each side.\n    center = (options.em_to_px(width) / 2, options.em_to_px(0.5 + svgling.core.NodePos.descender_margin))\n    if sideways and len(text) &gt; 1:\n        # exercise left to reader: arbitrary positioning/sizing for sideways nodes that are &gt; 1 char\n        raise NotImplementedError(\"Sideways rotation requires len(text)==1\")\n    degrees = sideways and 90 or 180\n    svgtext.rotate(degrees, center)\n    svg_parent.add(svgtext)\n    return svgling.core.NodePos(svg_parent, x=50, y=0, width=width, height=1.0, options=options, text=f\"flip_node({text})\")\n\nFor debugging purposes, the return value of one of these objects can be inspected directly (though note that exceptions will not be shown unless you manually call _repr_svg_):\n\nflip_node(\"Table\")\n\n\n\n\n\nsvgling.draw_tree(\"Emoji\", \"(╯°□°)╯\", flip_node(\"(\", sideways=True), flip_node(\"Table\"))"
  },
  {
    "objectID": "manual.html#annotating-constituents",
    "href": "manual.html#annotating-constituents",
    "title": "svgling Manual",
    "section": "5.1 Annotating constituents",
    "text": "5.1 Annotating constituents\nIf you want to highlight a specific constituent, you can draw a box around it, and/or underline it.\n\n(svgling.draw_tree(t1)\n     .underline_constituent((0,))\n     .underline_constituent((1,1)))\n\n\n\n\nBoth of these functions accept a number of extra svg arguments determining the details of the annotation. For box_constituent, you can pass stroke, stroke_width, fill, fill_opacity, and rounding. For underline_constituent you can pass stroke, stroke_width, and stroke_opacity. As can be seen above, boxes default to light non-opaque gray with rounded edges, and no stroke."
  },
  {
    "objectID": "manual.html#movement-arrows",
    "href": "manual.html#movement-arrows",
    "title": "svgling Manual",
    "section": "5.2 Movement arrows",
    "text": "5.2 Movement arrows\nMovement arrows can be drawn between arbitrary constituents; svgling will attempt to keep them from overlapping with each other or with the tree. The arrow always starts below the center of the first constituent, descends, moves horizontally, and attaches vertically to the center of the second constituent. It can be convenient to combine arrows with some kind of constituent-grouping annotation, for complex constituents. The following example illustrates movement arrows in a typical case of Quantifier Raising.\n\nt4 = (\"TP\", (\"DP\", (\"D\", \"every\"), (\"NP\", (\"N\", \"cat\"))),\n           (\"TP\", \"1\", (\"TP\", (\"DP\", (\"D\", \"some\"), (\"NP\", (\"N\", \"dog\"))),\n                     (\"TP\", \"3\", (\"TP\", (\"DP\", svgling.core.subscript_node(\"t\", \"1\")),\n                                  (\"VP\", (\"V\", \"likes\"), (\"DP\", svgling.core.subscript_node(\"t\", \"3\"))))))))\n(svgling.draw_tree(t4)\n    .movement_arrow((1,1,1,1,0), (0,))\n    .underline_constituent((0,))\n    .movement_arrow((1,1,1,1,1,1), (1,1,0), stroke_width=1, stroke=\"black\")\n    .underline_constituent((1,1,0)))"
  },
  {
    "objectID": "manual.html#hybrid-diagram-compatibility",
    "href": "manual.html#hybrid-diagram-compatibility",
    "title": "svgling Manual",
    "section": "7.1 Hybrid diagram compatibility",
    "text": "7.1 Hybrid diagram compatibility\nHybrid rendering introduces some compatibility quirks, and Latex rendering in nodes in particular may vary across frontends. It is known not to work entirely in colab and VSCode. In some frontends, it may be useful to enable the markdown compatibility mode, which embeds tree rendering in IPython.display.Markdown-style objects, rather than regular HTML/Latex. In particular, this mode will enable quarto rendering of the MathJax examples in this section. To enable this, use:\nsvgling.html.compat(svgling.html.Compat.USE_MARKDOWN)\nNote that because Markdown in block-level HTML elements is not supported by the relevant markdown standards, using this mode should not have an effect on how trees or defined (and unfortunately does not allow embedding markdown in tree nodes). It will, however, interfere with the use of \\(..\\) and \\[..\\] as MathJax delimiters, and isn’t compatible with all tree layout settings.\nCaveat: some frontends, in particular, colab, strip all styling from HTML in Markdown. This compatibility setting will therefore work only in some cases.\nLimitations and quirks of svgling.html:\n\nBranching can be at most binary.\nNot supported: horizontal alignment, edge/per-node styles via the svgling.core API (only via raw html), tree annotations, automatic linebreaking (use html linebreaks).\nLimited support: composite figures (svling.figure.HTMLSideBySide only), TreeOption settings (see below; many of these can be handled directly in HTML/CSS)\nStanding bug: non-leaf nodes do not contribute correctly to the tree size calculations, resulting in extra whitespace in the left daughter branch for very wide parent nodes.\nTechnical limitation: html entities are not allowed.\nRendering outside of core Jupyter lab is not fully supported. MathJax rendering is dependent on frontend support for rendering latex in HTML output. This is best supported for core jupyter, and in particular, is broken in both colab and VSCode. Rendering is also affected by containing css, which can sometimes be quite unexpected (e.g. quarto rendered diagrams have to factor in that quarto uses bootstrap).\n\nSupported and unsupported TreeOptions parameters\n\nSupported: distance_to_daughter, tree_split, font_style and font_size (may get overridden by html or css)\nPartial support: debug (doesn’t show grid), horiz_spacing (only TEXT and EVEN; TEXT is the default. EVEN is unreliable across frontends.)\nNot supported: vert_align, leaf_padding (use CSS), leaf_nodes_align, descend_direct, text options (use CSS), average_glyph_width"
  },
  {
    "objectID": "manual.html#file-output",
    "href": "manual.html#file-output",
    "title": "svgling Manual",
    "section": "8.1 File output",
    "text": "8.1 File output\nTo save SVG output to a file, see the svgwrite.Drawing api; any object returned by draw_tree(...).get_svg() is Drawing object. For convenience, svgling classes also pass through saveas. For example:\n\n# # uncomment to write to `demotree.svg` with human-readable formatting\n# demo_tree = (\"S\", (\"NP\", (\"D\", \"the\"), (\"N\", \"elephant\")), (\"VP\", (\"V\", \"saw\"), (\"NP\", (\"D\", \"the\"), (\"N\", \"rhinoceros\"))))\n# svgling.draw_tree(demo_tree).saveas(\"demotree.svg\", pretty=True)\n\n(Since SVG is just text/xml, it can of course be written to a file via all sorts of other means.)\nIn addition, the module itself supports generating svg at the command line, if passed a valid tree description via python data structures. For example, the following command (on linux/macos) will generate the same file:\npython -m svgling '(\"S\", (\"NP\", (\"D\", \"the\"), (\"N\", \"elephant\")), (\"VP\", (\"V\", \"saw\"), (\"NP\", (\"D\", \"the\"), (\"N\", \"rhinoceros\"))))' &gt; demotree.svg"
  },
  {
    "objectID": "manual.html#format-conversion",
    "href": "manual.html#format-conversion",
    "title": "svgling Manual",
    "section": "8.2 Format conversion",
    "text": "8.2 Format conversion\nTo convert generated svg images to other formats both raster and vector, you have many options, both interactive and not. Sometimes the quickest option to get a raster image is simply to use your OS’s screenshot tool, e.g. on mac, Shift+⌘+4 (and then select a screen region). For a more structured approach, svgling provides builtin support for doing format conversion via the cairosvg package if it’s installed. The svgling.utils module provides a light wrapper for cairosvg’s svg2png, svg2pdf, and svg2ps that take any IPython svg-rendering object as their first argument, and otherwise have the same api as the corresponding cairosvg functions.\n\nIf write_to is set, these functions will write to a file; otherwise they return a byte object. For the svgling.utils.svg2png(..) function, the returned object is conveniently compatible with IPython.display.Image for display in Jupyter frontends, as in the example below.\nThey take various parameters including scale, height, width, dpi, etc.\nSee the cairosvg documentation for details on other named parameters that these functions accept.\nWarning: one point of SVG images is that they are vector images, and therefore will appear as crisp as possible at all resolutions. This is not true of raster images! It’s recommended that you render to raster at a high enough resolution that the DPI can match whatever display device is intended. For embedding in other vector formats, for example PDF via LaTeX, conversion using svg2pdf may be more appropriate than raster conversion.\n\n\nimport svgling.utils, svgling.semantics, nltk\nfrom IPython.display import Image\nt = svgling.semantics.DoubleBrackets(nltk.Tree.fromstring(\"(S (NP (D the) (N elephant)) (VP (V saw) (NP (D the) (N rhinoceros))))\"))\nImage(svgling.utils.svg2png(t, scale=1.5))\n# or, to generate a file, uncomment:\n# svgling.utils.svg2png(t, scale=2, write_to=\"elephant.png\")"
  }
]